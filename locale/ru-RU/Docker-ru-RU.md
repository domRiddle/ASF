# Docker

Начиная с версии 3.0.3.2, ASF также доступен в формате **[контейнера docker](https://www.docker.com/what-container)**. Запуск ASF в контейнере docker обычно не имеет никаких преимуществ для обычных пользователей, он это может оказаться отличным способом использования ASF на серверах, позволяющий запускать ASF в среде, изолированной от других приложения. Наш репозиторий docker вы можете найти **[здесь](https://hub.docker.com/r/justarchi/archisteamfarm)**.

* * *

## Теги

В ASF доступные 4 основных типа **[тегов](https://hub.docker.com/r/justarchi/archisteamfarm/tags)**:

### `master`

Этот тег всегда указывает на сборку ASF из последнего коммита в ветке master, это то же самое что и экспериментальная сборка AppVeyor, описанная в статье "**[Цикл выпуска](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Release-cycle-ru-RU)**". Обычно вам стоит избегать использования этого тега, поскольку на этом уровне в программе наибольшая вероятность наличия ошибок, и эта сборка предназначена для разработчиков и продвинутых пользователей принимающих участие в разработке. Этот образ обновляется с каждым коммитом в ветку master на GitHub, поэтому вы можете ожидать очень частых обновлений (и отказов), так же как и со сборкой AppVeyor. Эта сборка отображает текущее состояние проекта ASF, и не гарантируется что она стабильна и протестирована, как и указано в описании цикла выпуска. Этот тег не следует использовать в среде реального применения.

### `released`

По аналогии с тегом выше, этот тег всегда соответствует последней **[версии ASF](https://github.com/JustArchiNET/ArchiSteamFarm/releases)**, включая предварительные. В сравнении с тегом `master`, этот образ обновляется каждый раз когда создаётся новый тег на GitHub. Предназначен для продвинутых пользователей, которые предпочитают самые свежие версии программного обеспечения, находящиеся на грани того, что можно считать стабильным. Мы рекомендуем это если вы по какой-то причине не хотите использовать тег `latest`. Пожалуйста, обратите внимание, что использование этого тега аналогично использованию **[предварительных версий](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Release-cycle-ru-RU)**.

### `latest`

Этот тег, по сравнению с другими, единственный включает в себя автоматические обновления ASF и обычно указывает на одну из стабильных версий, но не обязательно последнюю. Цель этого тега - предоставить разумный контейнер Docker по умолчанию, способный запускать само-обновляемую сборку ASF под конкретную ОС. Поэтому этот образ не должен обновляться как можно чаще, поскольку используемая версия ASF способна при необходимости обновиться самостоятельно. Разумеется, `UpdatePeriod` можно спокойно выключить (поставить равным `0`), но в этом случае вам наверное лучше использовать фиксированный билд `A.B.C.D`. Аналогично, вы можете изменить значение по умолчанию в `UpdateChannel` чтобы сделать авто-обновляемым тег `released`.

Из-за того факта, что образ `latest` имеет возможность автоматического обновления, он включает в себя только чистую ОС с версией ASF для этой ОС, в отличии от всех других тегов, которые включают в себя ОС со средой выполнения .NET Core и универсальную версию ASF. Это связано с тем, что более новая (обновленная) версия ASF может потребовать более новую среду выполнения, чем та, с которой собран образ, что в противном случае потребовало бы пересборку заново, сводя на нет планируемый вариант использования.

### `A.B.C.D`

В сравнении с тегами выше, этот тег полностью зафиксирован, это означает что образ не будет обновляться после публикации. Это работает аналогично сборкам на GitHub, которые никогда не меняются после выпуска, что гарантирует стабильную и неизменную среду. Обычно вы можете захотеть использовать этот тег если вы хотите определённую версию ASF(более старую чем `latest`) и не хотите использовать никаких авто-обновлений (например, предоставляемых в теге `latest`).

* * *

## Какой тег лучше для меня?

Это зависит от того, что вам нужно. Для большинства пользователей наилучшим будет тег `latest`, поскольку он предоставляет в точности то же, что и ASF для домашних ПК, но в особом контейнере Docker в качестве услуги. Люди, которые пересобирают свои образы достаточно часто и хотели бы использовать версию ASF, привязанную к заданной сборке могут использовать тег `released`. Если же вы вместо этого хотите конкретную и фиксированную версию ASF, которая никогда не изменится без вашего явного желания, то для вас доступны сборки `A.B.C.D` на различных этапах развития, к которым вы всегда можете вернуться.

Мы обычно не рекомендуем использовать сборки `master`, как и автоматические сборки AppVeyor - эта сборка нужна чтобы отразить текущее состояние проекта ASF. Нет никаких гарантий что это состояние будет правильно работать, но конечно же вы можете попробовать его использовать если интересуетесь разработкой ASF.

* * *

## Архитектуры

Образы docker с ASF доступны для 3 архитектур - `x64,`, `arm` и `arm64`. Вы можете прочитать больше об этом в разделе **[Совместимость](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Compatibility-ru-RU)**.

Поскольку мульти-архитектурные теги Docker пока ещё в процессе разработки, сборки под архитектуры, отличающиеся от архитектуры по умолчанию `x64` на данный момент доступны доступны под тегами с суффиксом `-{ARCH}`. Другими словами, если вы хотите использовать тег `latest` для архитектуры `arm`, просто используйте тег `latest-arm`.

* * *

## Использование

Полную справку вы можете найти в **[официальной документации docker](https://docs.docker.com/engine/reference/commandline/docker)**, а мы в этом руководстве рассмотрим только базовое использование, но вы можете узнать больше самостоятельно.

### Hello ASF!

Для начала нам надо проверить что наш docker работает правильно, и этот пример послужит для ASF своего рода "**<a href=https://ru.wikipedia.org/wiki/Hello,_world!>hello world</a>**":

```shell
docker pull justarchi/archisteamfarm
docker run -it --name asf --rm justarchi/archisteamfarm
```

Команда `docker pull` обеспечивает чтобы использовался самый свежий образ `justarchi/archisteamfarm`, просто на случай если у вас закеширована устаревшая версия. `docker run` создаёт новый контейнер docker с ASF и запускает его на переднем плане (`-it`). `--rm` гарантирует, что ваш контейнер будет очищен после остановки, поскольку пока мы просто тестируем, что всё нормально работает.

Если всё завершилось успешно, после получения всех слоев и запуска контейнера вы должны увидеть что ASF успешно запустился и сообщил вам что в нём не задано ботов, это хорошо - мы проверили что ASF корректно работает в docker. Нажмите `CTRL+P` а затем `CTRL+Q` чтобы выйти контейнера docker на переднем плане, а затем остановите контейнер с ASF командой `docker stop asf`.

Если вы внимательно посмотрите на команды выше, вы заметите что мы не задали тег, и поэтому по умолчанию автоматически используется тег `latest`. Если вы хотите использовать тег, отличный от `latest`, например `latest-arm`, его надо задать в явном виде:

```shell
docker pull justarchi/archisteamfarm:latest-arm
docker run -it --name asf --rm justarchi/archisteamfarm:latest-arm
```

* * *

## Использование тома

Если вы используете ASF в контейнере docker то очевидно что вам нужно сконфигурировать саму программу. Это можно сделать различными методами, но мы рекомендуем создать папку ASF `config` на локальной машине, и подключить её как общий том к контейнеру docker с ASF.

Например, предположим что ваша папка config для ASF находится по адресу `/home/archi/ASF/config`. Эта папка содержит `ASF.json` а также файлы конфигурации для ботов, которых мы хотим запустить. Теперь всё что нам нужно сделать это просто подключить эту папку как общий том к нашему контейнеру docker, там где ASF ожидает найти свою папку конфигурации (`/app/config`).

```shell
docker pull justarchi/archisteamfarm
docker run -it -v /home/archi/ASF/config:/app/config --name asf justarchi/archisteamfarm
```

Вот и всё, теперь ваш контейнер docker с ASF будет использовать общую папку с вашей локальной машины в режиме чтения и записи, а это всё что вам нужно для конфигурирования ASF. Аналогичным образом вы можете смонтировать другие тома, которые вы хотите сделать общими с ASF, например `/app/logs` или `/app/plugins`.

Разумеется, это только один из возможных способов получить желаемое, никто не мешает вам, к примеру, создать свой собственный `Dockerfile` который будет копировать файлы конфигурации в папку `/app/config` в контейнере docker с ASF. В этой инструкции мы описываем только основы использования.

### Разрешения для тома

ASF по умолчанию запускается под пользователем `root` внутри контейнера. С точки зрения безопасности это не проблема, поскольку мы уже находимся внутри контейнера Docker, но это влияет на общий том, поскольку созданные в нём файлы будут обычно иметь в качестве владельца `root`, что может быть нежелательным при использовании общего тома.

Docker позволяет вам указать **[флаг](https://docs.docker.com/engine/reference/run/#user)** ` --user` команде `docker run`, что задаст пользователя по умолчанию, под которым будет запускаться ASF. Вы можете посмотреть ваши `uid` и `gid` например с помощью команды `id`, и затем передать их в команде. Например, если нужный вам пользователь имеет `uid` и `gid` равные 1000:

```shell
docker pull justarchi/archisteamfarm
docker run -it -u 1000:1000 -v /home/archi/ASF/config:/app/config --name asf justarchi/archisteamfarm
```

Не забывайте что по умолчанию папка `/app`, используемая ASF, всё равно принадлежит `root`. Если вы запустите ASF от произвольного пользователя, то ваш процесс ASF не будет иметь прав на запись в свои собственные файлы. Этот доступ не является обязательным для работы, но он необходим например для автоматического обновления. Чтобы это исправить достаточно сменить владельца всех файлов ASF со значения по умолчанию `root` на нужного вам пользователя.

```shell
docker exec -u root asf chown -hR 1000:1000 /app
```

Это нужно сделать только один раз после создания вашего контейнера командой `docker run`, и только если вы решите запускать процесс ASF под своим пользователем. Также не забывайте заменить аргумент `1000:1000` в командах выше на `uid` и `gid` которые вы реально хотите использовать для запуска ASF.

* * *

## Синхронизация нескольких экземпляров

ASF включает в себя поддержку синхронизации нескольких экземпляров, как описано в разделе "**[Совместимость](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Compatibility-ru-RU#user-content-Запуск-нескольких-экземпляров)**". Если вы запускаете ASF в контейнере docker, у вас также есть возможность "включиться" в этот процесс, в случае если у вас несколько контейнеров с ASF и вам нужно синхронизировать их между собой.

По умолчанию каждый ASF, запущенный внутри контейнера docker, автономен, а значит никакая синхронизация не происходит. Чтобы включить синхронизацию между ними, вы должны привязать путь `/tmp/ASF` в каждом контейнере ASF, который вы хотите синхронизировать, к одному общему пути хост-машины, в режиме чтения-записи. Это делается точно так же, как привязка томов, описанная выше, только с другими путями:

```shell
mkdir -p /tmp/ASF-g1
docker pull justarchi/archisteamfarm
docker run -v /tmp/ASF-g1:/tmp/ASF -v /home/archi/ASF/config:/app/config --name asf1 justarchi/archisteamfarm
docker run -v /tmp/ASF-g1:/tmp/ASF -v /home/john/ASF/config:/app/config --name asf2 justarchi/archisteamfarm
# И так далее, все контейнеры ASF теперь синхронизированы друг с другом
```

Мы рекомендуем привязывать папку `/tmp/ASF` вашего ASF тоже к временной папке `/tmp` на вашей машине, но конечно же вы вольны выбрать любую другую, удовлетворяющую вашим потребностям. Каждый контейнер ASF, который вы хотите синхронизировать, должен делить общую папку `/tmp/ASF` с другими контейнерами, также участвующими в процессе синхронизации.

Как вы наверное догадались из примера выше, можно также создать две "группы синхронизации", привязав разные пути на хост-машине docker в папке `/tmp/ASF` в ASF.

Привязка `/tmp/ASF` совершенно необязательна и даже не рекомендуется, за исключением случая когда вы точно хотите синхронизировать два или более контейнера ASF. Мы не рекомендуем привязку `/tmp/ASF` для использования одного контейнера, поскольку это не несёт совершенно никакой пользы если вы планируете запускать только один контейнер ASF, и может даже привести к проблемам, которых можно было избежать.

* * *

## Аргументы командной строки

ASF позволяет передавать **[аргументы командной строки](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Command-line-arguments-ru-RU)** в контейнер docker используя переменные среды. Вам следует использовать выделенные переменные среды для поддерживаемых аргументов, и переменную `ASF_ARGS` для всего остального. Это достигается путём добавления к команде `docker run` параметра `-e`, например:

```shell
docker pull justarchi/archisteamfarm
docker run -it -e "ASF_CRYPTKEY=MyPassword" -e "ASF_ARGS=--process-required" --name asf justarchi/archisteamfarm
```

Этот пример корректно передаст ваш аргумент `--cryptkey` процессу ASF, запущенному внутри контейнера docker, а также передаст остальные аргументы. Разумеется, если вы продвинутый пользователь, вы также можете изменить `ENTRYPOINT` или добваить `CMD` и передавать нужные аргументы командной строки самостоятельно.

Кроме случая, когда вы хотите передать ключ шифрования или иные продвинутые опции, обычно вам нет нужны указывать переменные среды, поскольку наши контейнеры docker уже сконфигурированы на запуск с разумными параметрами по умолчанию `--no-restart`, `--process-required` и `--process-required`, поэтому, как видите, `ASF_ARGS` в примере выше избыточен, и только `ASF_CRYPTKEY` имеет смысл.

* * *

## IPC

Для использования IPC, вам сначала нужно установить **[параметру глобальной конфигурации](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Configuration-ru-RU#user-content-Файл-глобальной-конфигурации)** `IPC` значение `true`. В добавок к этому, вам **необходимо** заменить адрес ожидания запросов по умолчанию `localhost`, поскольку docker не может маршрутизировать внешний трафик на loopback-интерфейс. Пример настройки, при которой запросы будут ожидаться со всех интерфейсов - `http://*:1242`. Разумеется, вы можете указать также более строгие настройки, такие как только приём запросов только от внутренней сети, или сети VPN, но это должен быть маршрут, доступный извне - `localhost` не подходит, поскольку этот маршрут полностью находится внутри гостевой машины.

Чтобы сделать описанное выше, вам нужно использовать **[пользовательскую конфигурацию IPC](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/IPC-ru-RU#user-content-Пользовательская-конфигурация)**, аналогичную приведенной ниже:

```json
{
    "Kestrel": {
        "Endpoints": {
            "HTTP": {
                "Url": "http://*:1242"
            }
        }
    }
}
```

После того, как мы настроим IPC на использование интерфейса, отличного от loopback, нам нужно сообщить docker что необходимо подключить порт ASF `1242/tcp` с помощью аргумента командной строки `-P` либо `-p`.

Например, эта команда сделает доступным интерфейс ASF IPC (только) для хост-машины:

```shell
docker pull justarchi/archisteamfarm
docker run -it -p 127.0.0.1:1242:1242 -p [::1]:1242:1242 --name asf justarchi/archisteamfarm
```

Если вы всё настроили правильно, команда `docker run`, приведенная выше сделает возможной работу с интерфейсом **[IPC](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/IPC-ru-RU)** на вашей хост-машине, по стандартному адресу `localhost:1242`, который теперь корректно маршрутизируется на гостевую машину. Приятно отметить, что мы не маршрутизируем этот адрес дальше, поэтому соединение будет работать только с хост-машины docker, а значит останется безопасным.

* * *

### Полный пример

Объединив знания, полученные выше, мы можем сделать полный пример конфигурации, он будет выглядеть примерно так:

```shell
docker pull justarchi/archisteamfarm
docker run -it -p 127.0.0.1:1242:1242 -p [::1]:1242:1242 -v /home/archi/asf:/app/config --name asf justarchi/archisteamfarm
```

Предполагается, что у вас один контейнер с ASF, и все конфигурационные файлы ASF расположены в `/home/archi/asf`. Вам нужно изменить путь к конфигурационным файлам на соответствующий вашей машине. Эта конфигурация также готова к использованию IPC если вы решите включить в вашу папку конфигурации файл `IPC.config` со следующим содержимым:

```json
{
    "Kestrel": {
        "Endpoints": {
            "HTTP": {
                "Url": "http://*:1242"
            }
        }
    }
}
```

* * *

## Советы профессионалов

Когда ваш контейнер docker с ASF уже готов, вам не нужно каждый раз использовать команду `docker run`. Вы можете легко запускать/останавливать контейнер docker с ASF командами `docker stop asf` и `docker start asf`. Помните, что если вы не пользуетесь тегом `latest`, то обновление ASF потребует от вас снова выполнить `docker stop`, `docker rm`, `docker pull` и `docker run`. Это связано с тем, что вам нужно пересобирать ваш контейнер из свежего образа ASF каждый раз когда вы хотите использовать версию ASF, включенную в этот образ. Для образов с тегом `latest`, в ASF включена возможность автоматического обновления, поэтому пересборка образа не нужна для использования последней версии ASF (но делать это время от времени всё равно полезно, чтобы получить свежую среду выполнения .NET Core и используемую ОС).

Как сказано выше, ASF c тегами отличными от `latest` не будут обновляться автоматически, а это значит что **вы** отвечаете за использование последней версии репозитория `justarchi/archisteamfarm`. Это имеет много преимуществ, потому что обычно приложение не должно изменять свой код во время работы, но мы также понимаем удобство того факта что вам не нужно беспокоиться о версии ASF в контейнере docker. Если вас заботят хорошие практики и правильное использование docker, мы рекомендуем использовать тег `released` вместо `latest`, но если вы не хотите заботиться о нём и просто хотите чтобы ASF работало и обновлялось автоматически, тег `latest` тоже подойдёт.

Обычно вам следует запускать контейнер docker с ASF с глобальной настройкой `Headless: true`. Это явным образом укажет ASF что вы не сможете ввести недостающие данные и запрашивать их не следует. Разумеется, для начальной настройки вам стоит рассмотреть возможность оставить этот параметр равным `false`, чтобы вы легко могли всё настроить, но при длительном использовании вы обычно не привязаны к консоли ASF, и поэтому имеет смысл сообщить об этом ASF и использовать при необходимости **[команду](https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Commands-ru-RU)** `input`. Таким образом ASF не придётся бесконечно ждать пользовательского ввода, который никогда не произойдёт (и тратить на это ресурсы). Это также позволит запускать ASF внутри контейнера в не-интерактивном режиме, что может быть чрезвычайно полезно, например, для пересылки сигналов, делая возможным штатное завершение ASF по запросу `docker stop asf`.